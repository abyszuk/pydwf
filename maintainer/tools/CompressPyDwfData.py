#! /usr/bin/env python3

"""Compress stuff and turn it into binary data, so we can make it part of a release."""

import os
import glob
import subprocess
import base64
import contextlib
import tempfile
import shutil


def chop(s: str, n: int):
    """Chop string *s* in pieces of length *n*. The last piece may be shorter than *n*."""
    i = 0
    result = []
    while i < len(s):
        result.append(s[i:i+n])
        i += n
    return result


def zip_directory_to_blob(source_dir, name):
    """Copy a directory, zip it, and return the zip-file as a binary blob."""
    source_dir = os.path.abspath(source_dir)
    with tempfile.TemporaryDirectory() as temp_dir:
        original_working_directory = os.getcwd()
        os.chdir(temp_dir)
        try:
            ignore_func = shutil.ignore_patterns(".gitignore")
            shutil.copytree(source_dir, name, ignore=ignore_func)
            zipfile = name + ".zip"
            command_args = ["zip", "-o", "-r9", zipfile, name]
            subprocess.run(command_args, capture_output=True)
            with open(zipfile, "rb") as fi:
                data = fi.read()
        finally:
            os.chdir(original_working_directory)
    return data


def glob_file_to_blob(glob_filename, name):
    """Copy a file, zip it, and return the zip-file as a binary blob."""
    glob_filenames = glob.glob(glob_filename)
    if len(glob_filenames) != 1:
        raise RuntimeError("Expected to find 1 filename, found: {}".format(glob_filenames))
    src_filename = os.path.abspath(glob_filenames[0])
    basename = os.path.basename(src_filename)
    with tempfile.TemporaryDirectory() as temp_dir:
        original_working_directory = os.getcwd()
        os.chdir(temp_dir)
        try:
            shutil.copyfile(src_filename, basename)
            zipfile = name + ".zip"
            command_args = ["zip", "-o", "-r9", zipfile, basename]
            subprocess.run(command_args, capture_output=True)
            with open(zipfile, "rb") as fi:
                data = fi.read()
        finally:
            os.chdir(original_working_directory)
    return data


def main():

    target_specifications = {
        ("examples"   , "pydwf-examples"   , "directory", "../../source/pydwf-examples"),
        ("html_docs"  , "pydwf-html-docs"  , "directory", "../../documentation/build/html"),
        ("pdf_manual" , "pydwf-pdf-manual" , "glob-file", "../../documentation/build/latex/pydwf-[0-9]*.pdf")
    }

    output_directory = "../../source/pydwf/data/"

    for (import_name, target_name, target_type, target_path) in target_specifications:

        output_filename = os.path.join(output_directory, import_name + ".py")

        if target_type == "directory":
            target_data = zip_directory_to_blob(target_path, target_name)
        elif target_type == "glob-file":
            target_data = glob_file_to_blob(target_path, target_name)
        else:
            assert False

        print("Writing {} ({} bytes) ...".format(output_filename, len(target_data)))

        with open(output_filename, "w") as fo, contextlib.redirect_stdout(fo):

            print("\"\"\"This module contains zipped, base64-encoded data that can be extracted.")
            print()
            print("Warning:")
            print("    This code was generated by the 'CompressPyDwfData.py' script, do not edit by hand!")
            print("\"\"\"")
            print()
            print("# pylint: disable=too-many-lines")
            print()

            print("data = \"\"\"")
            for line in chop(base64.b64encode(target_data).decode("ascii"), 80):
                print(line)
            print("\"\"\"")


if __name__ == "__main__":
    main()
